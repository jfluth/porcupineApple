; -----------------------------------------------------------------
; pick_ships.psm - PicoBlaze program for choosing where to place  your ships
;
; Version:	1.3
; Author:	Andrew Northy
; Date:		07-Dec-2014
;
; Revision History
; ================
; 25-Nov-14    AN    Created the first version, used project 2 as a starting template. Transition States 0 and most of 1 are done
; 01-Dec-14    AN    Added portions of collision detection algorithm, changed some portions of addresses to interface with RAM
; 02-Dec-14    AN    Finished State 2, updated incorrect labelling for transitioning from state 1 into state 2 (was called state 3)
; 02-Dec-14    AN    Finished State 3 and 4, code is assembling, must be tested

; 06-Dec-14    AN    Updated constants and RAM writes to have value and address.
; 08-Dec-14    AN	 Fixed bug with Orientation defaulting to NORTH if no buttons pressed during 
; 08-Dec-14    AN    More bug fixes, previously could not place ships touching the border. Added Jordan's updated code as well
;
; Description:
; ============
; Coming soon, to a comment header block near you....
; Choose ships, five states
; Idle, Pick X,Y anchor, Pick Orientation, Save to RAM, Finish
;
; Program initializes variables and sits in Idle state until it 
; receives connection complete signal from hardware.
;
; -----------------------------------------------------------------	

; ============================================
; === Register Names                       ===
; === s6 - s0 registers are not dedicated  ===
; === and keep their default names         ===
; ============================================
NAMEREG		sF,		Cursor			; Current location of cursor, MSB are X, LSB are Y
NAMEREG		sE,		Orien			; Current orientation. Only using first four bits, could add to this if needed
NAMEREG		sD,		Ship_info		; MSB are ship_count, LSB are ship_length
									; 5 ships to be placed, of varying length
										; 5, 4, 3, 3, 2
NAMEREG		sC,		But_input		; Input button values 
NAMEREG		sB,		valid_flag		; Current Selection is valid or not. Only 1 bit used, could combine if needed. 
									;
									; Dig7, Dig6, Dig5 and Dig4 are stored in the scratchpad
									; RAM to keep the changes to minimum
NAMEREG		sA,		Dig3			; 7-segment display digit 3
NAMEREG		s9,		Dig2			; 7-segment display digit 2
NAMEREG		s8,		Dig1			; 7-segment display digit 1
NAMEREG		s7,		Dig0			; 7-segment display digit 0


; ======================
; === Port Addresses ===
; ======================

; Nexys 4 board base I/O interface ports compatible with the Nexys3 I/O interface
;  Port Addresses
CONSTANT	PA_PBTNS,		00		; (i) pushbuttons inputs
CONSTANT	PA_SLSWTCH,		01		; (i) slide switches
CONSTANT	PA_LEDS,		02		; (o) LEDs
CONSTANT	PA_DIG3,		03		; (o) digit 3 port address
CONSTANT	PA_DIG2,		04		; (o) digit 2 port address
CONSTANT	PA_DIG1,		05		; (o) digit 1 port address
CONSTANT	PA_DIG0,		06		; (o) digit 0 port address
CONSTANT	PA_DP,			07		; (o) decimal points 3:0 port address
CONSTANT	PA_OOB,			08		; (o) Out of Bounds port address


; Interface registers
CONSTANT	PA_CONN_EST,	09		; (i) Connect has been established
CONSTANT	PA_CURSOR_CHECK,0A		; (o) Read address request to block RAM
CONSTANT	PA_RAM_W_ADDR,	0B		; (o) Write to block RAM location
CONSTANT	PA_VALID_FLAG,	0C		; (i) Requested data from RAM returned back, position is valid or not
CONSTANT	PA_PLACE_DONE,	0D		; (o) Ship placement completed signal
CONSTANT	PA_ORIEN,		0E		; (o) Orientation output
CONSTANT	PA_SHIP_INFO,	0F		; (o) Ship Info output

; Extended I/O interface port addresses for the Nexys4.  Your Nexys4_Bot interface module
; should include these additional ports even though they are not used in this program
CONSTANT	PA_PBTNS_ALT,	10		; (i) pushbutton inputs alternate port address
CONSTANT	PA_SLSWTCH1508,	11		; (i) slide switches 15:8 (high byte of switches
CONSTANT	PA_LEDS1508,	12		; (o) LEDs 15:8 (high byte of switches)
CONSTANT	PA_DIG7,		13		; (o) digit 7 port address
CONSTANT	PA_DIG6,		14		; (o) digit 6 port address
CONSTANT	PA_DIG5,		15		; (o) digit 5 port address
CONSTANT	PA_DIG4,		16		; (o) digit 4 port address
CONSTANT	PA_DP0704,		17		; (o) decimal points 7:4 port address
CONSTANT	PA_RAM_W_VAL,	18		; (o) Write to block RAM value

; Extended Rojobot interface registers.  These are alternate Port addresses
CONSTANT	PA_DATA_RX,			19	; (i) Data to read in from the RAM
CONSTANT	PA_SHIP_CHECK_0,	0A	; (o) Request to RAM to verify position is valid or not
CONSTANT	PA_SHIP_CHECK_1,	1A	; (o) Request to RAM to verify position is valid or not
CONSTANT	PA_SHIP_CHECK_2,	1B	; (o) Request to RAM to verify position is valid or not
CONSTANT	PA_SHIP_CHECK_3,	1C	; (o) Request to RAM to verify position is valid or not
CONSTANT	PA_SHIP_CHECK_4,	1D	; (o) Request to RAM to verify position is valid or not
CONSTANT	PA_DATA_TX,			1E	; (o) Data to write out to the RAM
CONSTANT	PA_DATA_RAM,		1F	; (i) Value of data in the RAM requested


; =====================================
; === Register bit mappings (masks) ===
; =====================================
CONSTANT	CURSOR_INIT,	44

CONSTANT	NORTH,	01
CONSTANT	EAST,	02
CONSTANT	SOUTH,	04
CONSTANT	WEST,	08

; Use masks below instead (MSK_BTN_UP, MSK_BTN_RIGHT, etc)
;CONSTANT	UP,		01
;CONSTANT	RIGHT,	02
;CONSTANT	DOWN,	03
;CONSTANT	LEFT,	04
;CONSTANT	SELECT,	05

CONSTANT	VALID,	01
CONSTANT	INVALID,00
CONSTANT	OUT_OF_BOUNDS, FF

CONSTANT	X_COOR,	F0
CONSTANT	Y_COOR,	0F

CONSTANT	MAX_X,	90
CONSTANT	MIN_X,	00	
CONSTANT	MAX_Y,	09
CONSTANT	MIN_Y,	00	
CONSTANT	INC_X,	10
CONSTANT	INC_Y,	01

CONSTANT	MAX_PLACE, 0A	; Tile placement cannot go past 09

CONSTANT	MY_TURN,	03
CONSTANT	HIS_TURN,	01

;CONSTANT	RAM_EMPTY,	00
;CONSTANT	RAM_MISS,	01
;CONSTANT	RAM_HIT,	02
CONSTANT	RAM_SHIP_H,	03
;Extras, may be used in stretch goal for cooler looking ships
CONSTANT	RAM_SHIP_V,	04
CONSTANT	RAM_SHIP_N,	05
CONSTANT	RAM_SHIP_E,	06
CONSTANT	RAM_SHIP_S,	07
CONSTANT	RAM_SHIP_W,	08

CONSTANT	STATE_0,	00
CONSTANT	STATE_1,	01
CONSTANT	STATE_2,	02
CONSTANT	STATE_3,	03
CONSTANT	STATE_4,	04

CONSTANT	INC_SHIPCNT, 10
CONSTANT	INC_SHIPLNG, 01

CONSTANT	MSK_CONN_EST, 80
CONSTANT	MSK_SHIPCNT,	F0
CONSTANT	MSK_SHIPLNG,	0F

;CONSTANT	MSK

	
;  bit masks for pushbuttons and switches for seven segment emulator
CONSTANT	MSK_ALLBTNS,	1F		; Buttons are in bits[5:0]
CONSTANT	MSK_PBTNS,		0F		; Mask for 4 buttons to display on LED
CONSTANT	MSK_BTN_CENTER,	10		; Pushbutton Center is bit 4
CONSTANT	MSK_BTN_LEFT,	08		; Pushbutton Left is bit 3
CONSTANT	MSK_BTN_UP,		04		; Pushbutton Up is bit 2
CONSTANT	MSK_BTN_RIGHT,	02		; Pushbutton Right is bit 1
CONSTANT	MSK_BTN_DOWN,	01		; Pushbutton Down is bit 0

CONSTANT	MSK_ALLSW_LO,	FF		; Slide switches are in bits[7:0] of PA_SLSWTCH_07_00
CONSTANT	MSK_ALLSW_HI,	FF		; Slide switchees are in bits[7:0] of PA_SLSWTCH_15_08
CONSTANT	MSK_SW7,		80		; Slide switch 7 is bit 7
CONSTANT	MSK_SW6,		40		; Slide switch 6 is bit 6
CONSTANT	MSK_SW5,		20		; Slide switch 5 is bit 5
CONSTANT	MSK_SW4,		10		; Slide switch 4 is bit 4
CONSTANT	MSK_SW3,		08		; Slide switch 3 is bit 3
CONSTANT	MSK_SW2,		04		; Slide switch 2 is bit 2
CONSTANT	MSK_SW1,		02		; Slide switch 1 is bit 1
CONSTANT	MSK_SW0,		01		; Slide switch 0 is bit 0

CONSTANT	MSK_SW15,		80		; Slide switch 15 is bit 7
CONSTANT	MSK_SW14,		40		; Slide switch 14 is bit 6
CONSTANT	MSK_SW13,		20		; Slide switch 13 is bit 5
CONSTANT	MSK_SW12,		10		; Slide switch 12 is bit 4
CONSTANT	MSK_SW11,		08		; Slide switch 11 is bit 3
CONSTANT	MSK_SW10,		04		; Slide switch 10 is bit 2
CONSTANT	MSK_SW09,		02		; Slide switch 09 is bit 1
CONSTANT	MSK_SW08,		01		; Slide switch 08 is bit 0


; bit mask for LEDs
CONSTANT	MSK_LEDS_LO,	FF		; Mask for rightmost 8 LEDs on the Nexys4
CONSTANT	MSK_LEDS_HI,	FF		; Mask for the lefmost 8 LEDs on the Nexys4


; bit mask for display character codes and decimal points
CONSTANT	MSK_CCODE,		1F		; Character codes are in lower 5 bits
CONSTANT	MSK_DECPTS,		0F		; Decimal points 3 - 0 are in bits 3 to 0
CONSTANT	MSK_DECPTS_HI,	0F		; Decimal points 7-4 are in bits 3 to 0
CONSTANT	MSK_HEXDIGIT,	0F		; Hex digits only take 4 bits


; nibble masks
CONSTANT	MSKLOWNIB,		0F		; Mask out high nibble of byte
CONSTANT	MSKHIGHNIB,		F0		; Mask out low nibble of byte
CONSTANT	INVLOWNIB,		0F		; Invert low nibble of byte


; =============================
; === State machine states  ===
; =============================

CONSTANT  STATE0,   00        ; Normal, go forward
CONSTANT  STATE1,   01        ; Off black line, back up
CONSTANT  STATE2,   02        ; Turn
CONSTANT  STATE3,   03        ; Go forward one space and check black line
CONSTANT  STATE4,   04        ; Go forward one space to the end of the maze, then turn off.

; =============================
; === MotCtl commands       ===
; =============================

CONSTANT  MOTCTRL_FWD,  33
CONSTANT  MOTCTRL_REV,  22
CONSTANT  MOTCTRL_R1X,  30
CONSTANT  MOTCTRL_L2X,  23

; =============================
; === Useful Data Constants ===
; =============================

;  Constants for True and False and Null
CONSTANT	FALSE,			00
CONSTANT	TRUE,			01
CONSTANT	NULL,			00

; Character code table for special characters
; Decimal digits 0 to 15 display '0'to 'F'
CONSTANT	CC_BASE,		10		; Base value for special characters
CONSTANT	CC_SEGBASE,		10		; Base value for segment display special characters
									;				 abcdefg
CONSTANT	CC_SEGA,		10		; Segment A		[1000000]
CONSTANT	CC_SEGB,		11		; Segment B		[0100000]
CONSTANT	CC_SEGC,		12		; Segment C		[0010000]
CONSTANT	CC_SEGD,		13		; Segment D		[0001000]
CONSTANT	CC_SEGE,		14		; Segment E		[0000100]
CONSTANT	CC_SEGF,		15		; Segment F		[0000010]
CONSTANT	CC_SEGG,		16		; Segment G		[0000001]
CONSTANT	CC_DOT,			17		; Dot (period)
CONSTANT	CC_UCH,			18		; Upper Case H
CONSTANT	CC_UCL,			19		; Upper Case L
CONSTANT	CC_UCR,			1A		; Upper Case R
CONSTANT	CC_LCL,			1B		; Lower Case L
CONSTANT	CC_LCR,			1C		; Lower Case R
CONSTANT	CC_SPACE1,		1D		; Space (blank)
CONSTANT	CC_SPACE2,		1E		; Space (blank)
CONSTANT	CC_SPACE,		1F		; Space (blank)


; ======================
; === BotInfo values ===
; ======================
CONSTANT	OR_N,			00		; Orientation is North
CONSTANT	OR_NE,			01		; Orientation is Northeast
CONSTANT	OR_E,			02		; Orientation is East
CONSTANT	OR_SE,			03		; Orientation is Southeast
CONSTANT	OR_S,			04		; Orientation is South
CONSTANT	OR_SW,			05		; Orientation is Southwest
CONSTANT	OR_W,			06		; Orientation is West
CONSTANT	OR_NW,			07		; Orientation is Northwest

CONSTANT	MV_STOP,		00		; Movement is stopped
CONSTANT	MV_FWD,			04		; Movement is forward
CONSTANT	MV_REV,			08		; Movement is reverse
CONSTANT	MV_SLT,			0C		; Movement is slow left turn
CONSTANT	MV_FLT,			0D		; Movement is fast left turn
CONSTANT	MV_SRT,			0E		; Movement is slow right turn
CONSTANT	MV_FRT,			0F		; Movement is fast right turn
									; Next 2 contants assume field is in low nibble
CONSTANT	MSKMVMT,	0F			; Mask out all but movement bits
CONSTANT	MSKORIENT,	07			; Mask out all but orientation bits

;=========================================
;
;========== JF CONSTANTS ================
;
;=========================================
CONSTANT 	RAM_EMPTY,  		00
CONSTANT 	RAM_MISS, 			01
CONSTANT 	RAM_HIT, 			02
CONSTANT 	RAM_SHIP, 			03


CONSTANT 	MISS_CODE, 			01
CONSTANT 	HIT_CODE, 			02
CONSTANT 	SHIP_CODE, 			03
CONSTANT 	LOSE_CODE, 			FF

CONSTANT 	MAX_HITS, 			11
CONSTANT 	DATA_READY_MASK, 	40


; =================================
; === Scratch Pad RAM Variables ===
; =================================

; Pushbutton translation lookup table.  Converts pushbutton combos
; to Motor Control input register format [lmspd[2:0],lmdir,rmspd[2:0],rmdir]
CONSTANT	SP_BTNBASE,	00			; table is based at 0x00
									;								[b3,b2,b1,b0]=[lf,lr,rf,rr]
CONSTANT	SP_LSRS,		00		; left motor off, right motor off 				[0000]
CONSTANT	SP_LORR,		02		; left motor off, right motor reverse			[0001]
CONSTANT	SP_LSRF,		03		; left motor off, right motor forward			[0010]
CONSTANT	SP_LSRFR,		00		; left motor off, right motor fwd & rev = off	[0011]
CONSTANT	SP_LRRS,		20		; left motor reverse, right motor off			[0100]
CONSTANT	SP_LRRR,		22		; left motor reverse, right motor reverse		[0101]
CONSTANT	SP_LRRF,		23		; left motor reverse, right motor forward		[0110]
CONSTANT	SP_LRRFR,		20		; left motor rev, right motor fwd & rev = off	[0111]
CONSTANT	SP_LFRS,		30		; left motor forward, right motor off 			[1000]
CONSTANT	SP_LFRR,		32		; left motor forward, right motor reverse		[1001]
CONSTANT	SP_LFRF,		33		; left motor forward, right motor forward		[1010]
CONSTANT	SP_LFRFR,		30		; left motor fwd, right motor fwd & rev = off	[1011]
CONSTANT	SP_LFRRS,		00		; left motor fwd & rev = off, right motor off	[1100]
CONSTANT	SP_LFRRR,		02		; left motor fwd & rev = off, right motor rev	[1101]
CONSTANT	SP_LFRRF,		03		; left motor fwd & rev = off, right motor fwd	[1110]
CONSTANT	SP_LFRRFR,		00		; left  and right motor fwd & rev = off			[1111]


; Movement display lookup table.  Converts movement from BotInfo register to
; the character code to display.  Not very dense but we have the room in the SP RAM and 
; it saves building a switch statement into the code.
CONSTANT	SP_MVMTBASE,	10			; table is based at 0x10

CONSTANT	SP_MVMT0,		18		; Stopped - display upper case H
CONSTANT	SP_MVMT1,		17		; Reserved - display dot to indicate error
CONSTANT	SP_MVMT2,		17		; Reserved - display dot to indicate error
CONSTANT	SP_MVMT3,		17		; Reserved - display dot to indicate error
CONSTANT	SP_MVMT4,		0F		; Forward - display upper case F
CONSTANT	SP_MVMT5,		17		; Reserved - display dot to indicate error
CONSTANT	SP_MVMT6,		17		; Reserved - display dot to indicate error
CONSTANT	SP_MVMT7,		17		; Reserved - display dot to indicate error
CONSTANT	SP_MVMT8,		0B		; Reverse (Backward) - display lower case B
CONSTANT	SP_MVMT9,		17		; Reserved - display dot to indicate error
CONSTANT	SP_MVMTA,		17		; Reserved - display dot to indicate error
CONSTANT	SP_MVMTB,		17		; Reserved - display dot to indicate error
CONSTANT	SP_MVMTC,		19		; Slow left turn - display upper case L
CONSTANT	SP_MVMTD,		1B		; Fast left turn - display lower case L
CONSTANT	SP_MVMTE,		1A		; Slow right turn - display upper case R
CONSTANT	SP_MVMTF,		1C		; Fast right turn - display lower case R


; ==============================
; === Storage for old values ===
; ==============================
CONSTANT	SP_SEM,			20		; Semaphore between isr and main loop
CONSTANT	SP_TEMP1,		21		; Temp storage.  Used by ISR
CONSTANT	SP_TEMP2,		22		;
;CONSTANT	SP_LMDIST,		23		; Storage for left and right motor distance counters
;CONSTANT	SP_RMDIST,		24		;
;CONSTANT	SP_OLDMVMT,		25		; Old movement value 
;CONSTANT	SP_OLDHDG,		26		; Old heading value
CONSTANT	SP_OLDDP,		27		; Old decimal points

; =========================
; === Digits 7, 6, 5, 4 ===
;==========================
CONSTANT	SP_DIG7,		30		; Digit[7:4] contain the BOT heading
CONSTANT	SP_DIG6,		31		;
CONSTANT	SP_DIG5,		32		;
CONSTANT	SP_DIG4,		33		;

; Scratchpad memory has up to 64 bytes (00 to 3F)

; ==========================================================
; === Variables for Project 2 that need to be saved/used ===
; ==========================================================
CONSTANT  SP_STATE,   34  ; Current state of the state machine
CONSTANT  SP_TURN,    35  ; Turn variable contains next direction to turn and how far
CONSTANT  SP_ORIENT,  36  ; Orientation we need to turn to
CONSTANT  SP_OOB,     37  ; Out of bounds value
CONSTANT  SP_PLACE_DONE,    38  ; Done placing


CONSTANT  SP_GAME_STATE, 	23
CONSTANT  SP_PLAYER_NUMBER, 24
CONSTANT  SP_GUESS, 		25
CONSTANT  SP_HIT_COUNT, 	26

CONSTANT  SP_PLAYER_ONE,    01
CONSTANT  SP_PLAYER_TWO,    02

CONSTANT  SP_SENDING, 		01
CONSTANT  SP_READ_BTNS,		02
CONSTANT  SP_RECEIVING,     03
CONSTANT  SP_SEND_ACK, 		04
CONSTANT  SP_RCVE_ACK, 		05
CONSTANT  SP_RCVE_RESULT, 	06

CONSTANT  ACK, 				FF
; ===============
; === main()  ===
; ===============

ADDRESS	000
				JUMP	main						; workaround to avoid location 3 corruption
				JUMP	main						; by Vivado Hardware Manager.  Bug was flagged by
				JUMP	main						; Ken Chapman and is known to be in 2014.2
				JUMP	main						; Address 003 can be corrupted by Vivado HW manager
													;
main:			CALL	init_btnluptbl				; initialize button to MotCtl lookup table
				CALL	init_mvmttbl				; initialize movement to character code lookup table
				LOAD	s1,		00					; clear the semaphore
				STORE	s1,		SP_SEM				;
				LOAD	s1,		00					; turn off decimal points 3-0.  Decimal point 0 (rightmost
				;STORE	s1,		SP_OLDDP			; and save the value	
				LOAD 	s1,		STATE0          	; Start in state 0
				STORE	s1,		SP_STATE
				; clear Out of Bounds
				;LOAD	s1, 00
				STORE	s1, SP_OOB
				;LOAD	s0, FALSE
				STORE	s0, SP_PLACE_DONE
				LOAD 	Cursor,	CURSOR_INIT         ; Initialize Cursor variable to center of the screen
				LOAD	Orien,	EAST				; Initialize Orientation to East
				LOAD	Ship_info,	55				; Initialize to 5 ships, current length 5
				
				CALL PLAYER_ASSIGN
						
				CALL	SS_wrdpts					; will be toggled in the interrupt handler
				LOAD	s1,		03					; turn on decimal points 5 and 4 to offset the movement digit
				CALL	SS_wrdpts_hi				; we don't need to save this value because these decimal points don't change
				ENABLE	INTERRUPT					; get the ball rolling
									

; ==================
; === Main  Loop ===
; ==================
													;	while(1) {  // main loop is an infinite loop
main_L0:		FETCH	s6,		SP_SEM				;		while (SP_SEMA == 0)  {}   // loop until isr updates rojobot registers
				COMPARE	s6,		00				;
				JUMP	Z,		main_L0				;
				;CALL	next_loc					;			Dig[3:2] = nex LocX; Dig[1:0] = next LocY
				CALL	next_mvmt					;			Dig[4] = next movement
				;CALL	next_hdg					;			Dig[7:4] = next heading
													;		}
				CALL TURN
													
				;DEBUG CODE: place Cursor.X into Dig1, and Cursor.Y into Dig0
				LOAD	s0, Cursor
				AND		s0, Y_COOR
				LOAD	Dig0, s0
				LOAD	s0, Cursor
				AND		s0, X_COOR
				SR0		s0
				SR0		s0
				SR0		s0
				SR0		s0
				LOAD	Dig1, s0
				
													
main_L2:		CALL	wr_alldigits				;		write all of the digits to the display
				LOAD	s1,		Cursor				;		update LEDs with new sensor information
				CALL	LED_wrleds					;
				CALL	next_step					;		tell rojobot what to do next
				FETCH	s6,		SP_SEM
				SUB	s6,		01					;		decrement semaphore
				STORE	s6,		SP_SEM				;
				JUMP	main_L0						;	} // end - main while loop	
				
													
								
			
;**************************************************************************************
; Support functions
;**************************************************************************************	

; ===============================================================================
; === wr_alldigits() - Writes all 8 display digits from the global locations  ===
; === Registers used s0,s1,s2, Dig0, Dig1, Dig2, Dig3                         ===
; --- Scratchpad RAM locations used SP_DIG4, SP_DIG5, SP_DIG6, SP_DIG7        ===
; ===============================================================================

wr_alldigits:										; Digits 0 to 3 are stored in registers	
													; and written to the didsplay with SS_wdigx()
				LOAD	s2,			00				; point at digit 0
				LOAD	s1,			Dig0			; and write it to display
				CALL	SS_wrdigx					;
				LOAD	s2,			01				; point at digit 1
				LOAD	s1,			Dig1			; and write it to display
				CALL	SS_wrdigx					;
				LOAD	s2,			02				; point at digit 2
				LOAD	s1,			Dig2			; and write it to display
				CALL	SS_wrdigx					;
				LOAD	s2,			03				; point at digit 3
				LOAD	s1,			Dig3			; and write it to the display
				CALL	SS_wrdigx					;
													; Digits 4 to 7 are stored in the Scratchpad RAM
													; and written to the display with SS_wdigx_hi()
				LOAD	s2,			04				; point at digit 4
				FETCH	s1,			SP_DIG4			; and write it to the display
				CALL	SS_wrdigx_hi				;
				LOAD	s2,			05				; point at digit 5
				FETCH	s1,			SP_DIG5			; and write it to the display
				CALL	SS_wrdigx_hi				;
				LOAD	s2,			06				; point at digit 6
				FETCH	s1,			SP_DIG6			; and write it to the display
				CALL	SS_wrdigx_hi				;
				LOAD	s2,			07				; point at digit 7
				FETCH	s1,			SP_DIG7			; and write it to the display
				CALL	SS_wrdigx_hi				;				
				RETURN
				
					
;*******
; Functions to convert pushbutton presses to Motor Control input
;*******				

; ===============================================================================
; === init_btnluptbl() - initialize button translation lookup table in SP RAM ===
; === Registers affected: s0, s1                                              ===
; ===============================================================================
init_btnluptbl:	LOAD	s0,		SP_BTNBASE			; s0 gets base of button translation lookup table
				LOAD	s1,		SP_LSRS				; s1 gets values for 0x00								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index
				LOAD	s1,		SP_LORR				; s1 gets values for 0x01								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index				
				LOAD	s1,		SP_LSRF				; s1 gets values for 0x02								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index
				LOAD	s1,		SP_LSRFR			; s1 gets values for 0x03								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index	
				LOAD	s1,		SP_LRRS				; s1 gets values for 0x04								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index
				LOAD	s1,		SP_LRRR				; s1 gets values for 0x05							
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index				
				LOAD	s1,		SP_LRRF				; s1 gets values for 0x06								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index
				LOAD	s1,		SP_LRRFR			; s1 gets values for 0x07								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index
				LOAD	s1,		SP_LFRS				; s1 gets values for 0x08								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index
				LOAD	s1,		SP_LFRR				; s1 gets values for 0x09								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index				
				LOAD	s1,		SP_LFRF				; s1 gets values for 0x0A								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index
				LOAD	s1,		SP_LFRFR			; s1 gets values for 0x0B								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index	
				LOAD	s1,		SP_LFRRS			; s1 gets values for 0x0C								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index
				LOAD	s1,		SP_LFRRR			; s1 gets values for 0x0D							
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index				
				LOAD	s1,		SP_LFRRF			; s1 gets values for 0x0E								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index
				LOAD	s1,		SP_LFRRFR			; s1 gets values for 0x0F								
				STORE	s1,		(s0)				; store the entry in the table
				RETURN								; done...at last			
				

; =============================================================================
; === btn2mot() - Button to MotCtl conversion function                      ===
; === Registers affected: s1, s2                                            ===
; === s0 contains the button value to convert.                              ===
; === Result (Motor Control register value) is returned in s1               ===
; === s0 (Button value) is not changed                                      ===
; =============================================================================
btn2mot:		LOAD	s2,		SP_BTNBASE			; s2 gets base of button conversion table
				LOAD	s1,		s0					; mask out upper nibble of buttons
				AND	s1,		MSKLOWNIB			; 
				ADD	s2,		s1					; s2 = Base + offset into table		
				FETCH	s1,		(s2)				; and fetch the entry
				RETURN															

				
; ===============================================================================
; === init_mvmttbl() - initialize movement translation lookup table in SP RAM ===
; === Registers affected: s0, s1                                              ===
; ===============================================================================
init_mvmttbl:	LOAD	s0,		SP_MVMTBASE			; s0 gets base of movement translation lookup table
				LOAD	s1,		SP_MVMT0			; s1 gets values for 0x00								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index
				LOAD	s1,		SP_MVMT1			; s1 gets values for 0x01								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index				
				LOAD	s1,		SP_MVMT2			; s1 gets values for 0x02								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index
				LOAD	s1,		SP_MVMT3			; s1 gets values for 0x03								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index	
				LOAD	s1,		SP_MVMT4			; s1 gets values for 0x04								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index
				LOAD	s1,		SP_MVMT5			; s1 gets values for 0x05							
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index				
				LOAD	s1,		SP_MVMT6			; s1 gets values for 0x06								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index
				LOAD	s1,		SP_MVMT7			; s1 gets values for 0x07								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index
				LOAD	s1,		SP_MVMT8			; s1 gets values for 0x08								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index
				LOAD	s1,		SP_MVMT9			; s1 gets values for 0x09								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index				
				LOAD	s1,		SP_MVMTA			; s1 gets values for 0x0A								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index
				LOAD	s1,		SP_MVMTB			; s1 gets values for 0x0B								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index	
				LOAD	s1,		SP_MVMTC			; s1 gets values for 0x0C								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index
				LOAD	s1,		SP_MVMTD			; s1 gets values for 0x0D							
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index				
				LOAD	s1,		SP_MVMTE			; s1 gets values for 0x0E								
				STORE	s1,		(s0)				; store the entry in the table
				ADD	s0,		01					; increment the table index
				LOAD	s1,		SP_MVMTF			; s1 gets values for 0x0F								
				STORE	s1,		(s0)				; store the entry in the table
				RETURN								; done...at last			
				

; =============================================================================
; === mvmt2cc() - movement to character code conversion function            ===
; === Registers affected: s1, s2                                            ===
; === s0 contains the movment value to convert.                             ===
; === Result (character code to display) is returned in s1                  ===
; === s0 (movement) is not changed                                          ===
; =============================================================================
mvmt2cc:		LOAD	s2,		SP_MVMTBASE			; s2 gets base of movment conversion table
				LOAD	s1,		s0					; mask out upper nibble of movment
				AND	s1,		MSKLOWNIB			; 
				ADD	s2,		s1					; s2 = Base + offset into table		
				FETCH	s1,		(s2)				; and fetch the entry
				RETURN															

				
;###############################################
; This function was changed for Battleship #####	
;###############################################		
			
; ========================================================================
; === next_mvmt() - Determine if we stay in or transition out of the   ===
; === current state                                                    ===
; === Registers affected: Dig3, s1, s0, SP_STATE, SP_TURN, SP_ORIENT,  ===
; === SP_OLDX, SP_OLDY                                                 ===
;
; This function looks at what current state the bot is in.
; It determines if a state-change condition has been met and updates the
; state appropriately. Any setup actions required upon entering a new 
; state are also handled here.
; This function does not change the MtrCtrl output register,
; that is handled in next_step based upon what state is set here.
; ========================================================================				
next_mvmt:		
		; clear Out of Bounds first
		LOAD	s0, 00
		STORE	s0, SP_OOB
		
        FETCH   s0, SP_STATE      ; Determine what state we are in
        COMPARE s0, STATE0
        JUMP    Z,  next_mvmt_s0  ; calculate next movement for state 0
        COMPARE s0, STATE1
        JUMP    Z,  next_mvmt_s1  ; calculate next movement for state 1
        COMPARE s0, STATE2
        JUMP    Z,  next_mvmt_s2  ; calculate next movement for state 2
        COMPARE s0, STATE3
        JUMP    Z,  next_mvmt_s3  ; calculate next movement for state 3
        JUMP    next_mvmt_s4      ; must be in state4, go calculate movement

; Idle state
next_mvmt_s0:
        LOAD    s0, But_input        ; Read input register to get conn est flag
        AND     s0, MSK_CONN_EST     ; Mask to have just connection established
        COMPARE s0, MSK_CONN_EST     ; If connection established signal is in, go to state 1
        JUMP    Z,  next_mvmt_go_s1       ; If we've reached the end, move forward one space and shut off.
        
        LOAD    s0, STATE0
        STORE   s0, SP_STATE      ; else, stay in state 0
        RETURN
        
; Pick X,Y anchor state
next_mvmt_s1:
        LOAD    s0, Ship_info          ; Read Ship Info to get ship count
        AND     s0, MSK_SHIPCNT      ; Mask to have just ship count
        ;COMPARE s0, 0     ; See if we are done	; This instruction is not needed, Z flag gets set in the AND operation if the result is Zero.
        JUMP    Z,	next_mvmt_go_s4  ; If have no ships left, transition to state 4
		
		;Check button input to potentially change state
		LOAD	s0, But_input		; Read button input
		AND		s0, MSK_ALLBTNS		; Mask out just the buttons
		COMPARE	s0, MSK_BTN_UP		; See if only the up button was pressed
		JUMP	Z,	next_mvmt_s1_chk_up
		COMPARE	s0, MSK_BTN_DOWN
		JUMP	Z,	next_mvmt_s1_chk_down
		COMPARE	s0, MSK_BTN_LEFT
		JUMP	Z,	next_mvmt_s1_chk_left
		COMPARE	s0, MSK_BTN_RIGHT
		JUMP	Z,	next_mvmt_s1_chk_right
		COMPARE	s0,	MSK_BTN_CENTER
		JUMP	Z,	next_mvmt_s1_chk_center
		
        LOAD    s0, STATE1
        STORE   s0, SP_STATE        ; else remain in state 1
		
        RETURN
		
next_mvmt_s1_chk_up:
		LOAD	s0,	Cursor		; Load Cursor var into s0
		AND		s0,	Y_COOR		; AND with Y_COOR to get just Y portion of it
		COMPARE	s0, MIN_Y		; Compare Y_coordinate with Minimum Y value 
		JUMP	Z,	next_mvmt_go_s1	; If we are at min Y value, do not update coordinate
		SUB		Cursor, INC_Y	; Else, Subtract y increment from Cursor for new location
		JUMP	next_mvmt_go_s1	; Read new location value and stay in state 1
		
next_mvmt_s1_chk_down:
		LOAD	s0,	Cursor		; Load Cursor var into s0
		AND		s0,	Y_COOR		; AND with Y_COOR to get just Y portion of it
		COMPARE	s0, MAX_Y		; Compare Y_coordinate with Maximum Y value 
		JUMP	Z,	next_mvmt_go_s1	; If we are at max Y value, do not update coordinate
		ADD		Cursor, INC_Y	; Else, Add y increment to Cursor for new location
		JUMP	next_mvmt_go_s1	; Read new location value and stay in state 1
		
next_mvmt_s1_chk_left:
		LOAD	s0,	Cursor		; Load Cursor var into s0
		AND		s0,	X_COOR		; AND with X_COOR to get just X portion of it
		COMPARE	s0, MIN_X		; Compare X_coordinate with Minimum X value 
		JUMP	Z,	next_mvmt_go_s1	; If we are at min X value, do not update coordinate
		SUB		Cursor, INC_X	; Else, Subtract x increment from Cursor for new location
		JUMP	next_mvmt_go_s1	; Read new location value and stay in state 1
		
next_mvmt_s1_chk_right:
		LOAD	s0,	Cursor		; Load Cursor var into s0
		AND		s0,	X_COOR		; AND with X_COOR to get just X portion of it
		COMPARE	s0, MAX_X		; Compare X_coordinate with Maximum X value 
		JUMP	Z,	next_mvmt_go_s1	; If we are at max X value, do not update coordinate
		ADD		Cursor, INC_X	; Else, Add x increment to Cursor for new location
		JUMP	next_mvmt_go_s1	; Read new location value and stay in state 1
		
next_mvmt_s1_chk_center:
		LOAD	s0, valid_flag	; Load the valid flag into s0
		COMPARE	s0,	VALID		; See if current selected location is valid
		JUMP	Z,	next_mvmt_go_s2	; If it is valid, go to state 2
		LOAD    s0, STATE1		; If selection is invalid, ignore command and remain in state 1
        STORE   s0, SP_STATE        ; else remain in state 1
        RETURN
		

; Pick Orientation state
next_mvmt_s2:
		;Check button input to potentially change state
		LOAD	s0, But_input		; Read button input
		AND		s0, MSK_ALLBTNS		; Mask out just the buttons
		COMPARE	s0, MSK_BTN_UP		; See if only the up button was pressed
		JUMP	Z,	next_mvmt_s2_chk_up
		COMPARE	s0, MSK_BTN_DOWN
		JUMP	Z,	next_mvmt_s2_chk_down
		COMPARE	s0, MSK_BTN_LEFT
		JUMP	Z,	next_mvmt_s2_chk_left
		COMPARE	s0, MSK_BTN_RIGHT
		JUMP	Z,	next_mvmt_s2_chk_right
		COMPARE	s0,	MSK_BTN_CENTER
		JUMP	Z,	next_mvmt_s2_chk_center
		JUMP	next_mvmt_go_s2			; No button, or a combination of buttons were pressed, do not update Orien
		
next_mvmt_s2_chk_up:
		LOAD	Orien,	NORTH	; Set Orientation to NORTH 
        JUMP	next_mvmt_go_s2	; Remain in State 2, recalc collision detection

next_mvmt_s2_chk_down:
		LOAD	Orien,	SOUTH	; Set Orientation to SOUTH
		JUMP	next_mvmt_go_s2	; Remain in State 2, recalc collision detection
        
next_mvmt_s2_chk_left:
		LOAD	Orien,	WEST	; Set Orientation to WEST
		JUMP	next_mvmt_go_s2	; Remain in State 2, recalc collision detection
        
next_mvmt_s2_chk_right:
		LOAD	Orien,	EAST	; Set Orientation to EAST
		JUMP	next_mvmt_go_s2	; Remain in State 2, recalc collision detection
        
next_mvmt_s2_chk_center:
		LOAD	s0, valid_flag	; Load the valid flag into s0
		COMPARE	s0,	VALID		; See if current selected location is valid
		JUMP	Z,	next_mvmt_go_s3	; If it is valid, go to state 3
		JUMP	next_mvmt_go_s1		; If selection is invalid, go back to state 1 to allow user to re-pick anchor
        
		
; Save to RAM state
next_mvmt_s3:
		LOAD	s1,	Ship_info	; get ship info reg to use later
		AND		s1,	MSK_SHIPLNG	; Mask to get just ship length
		
		LOAD	s0, Orien	; get ship orientation
		COMPARE	s0, NORTH	; See if we are pointing North
		JUMP	Z,	next_mvmt_s3_n
		COMPARE	s0,	EAST	; See if we are pointing East
		JUMP	Z,	next_mvmt_s3_e
		COMPARE	s0, SOUTH	; See if we are pointing South
		JUMP	Z,	next_mvmt_s3_s
		JUMP	next_mvmt_s3_w	; We must be pointing West
		
next_mvmt_s3_n:
		; Write values to RAM starting at anchor (Cursor) and subtracting Y value, ship_length times (s1)
		LOAD	s0, RAM_SHIP_H	; Load place ship value into what value we are writing to ram
		OUTPUT	s0, PA_RAM_W_VAL	; Tell the interface to write SHIP to RAM address
		LOAD	s0,	Cursor	; s0 becomes temp_cursor
		OUTPUT	s0, PA_RAM_W_ADDR
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_s3_done	; if temp_ship_length is zero, we are done
		SUB		s0, INC_Y	; Move temp_cursor one position
		OUTPUT	s0, PA_RAM_W_ADDR
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_s3_done	; if temp_ship_length is zero, we are done
		SUB		s0, INC_Y	; Move temp_cursor one position
		OUTPUT	s0, PA_RAM_W_ADDR
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_s3_done	; if temp_ship_length is zero, we are done
		SUB		s0, INC_Y	; Move temp_cursor one position
		OUTPUT	s0, PA_RAM_W_ADDR
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_s3_done	; if temp_ship_length is zero, we are done
		SUB		s0, INC_Y	; Move temp_cursor one position
		OUTPUT	s0, PA_RAM_W_ADDR
		JUMP	next_mvmt_s3_done	; max length is 5, so don't need to check anymore

next_mvmt_s3_e:
		; Write values to RAM starting at anchor (Cursor) and adding X value, ship_length times (s1)
		LOAD	s0, RAM_SHIP_H	; Load place ship value into what value we are writing to ram
		OUTPUT	s0, PA_RAM_W_VAL	; Tell the interface to write SHIP to RAM address
		LOAD	s0,	Cursor	; s0 becomes temp_cursor
		OUTPUT	s0, PA_RAM_W_ADDR
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_s3_done	; if temp_ship_length is zero, we are done
		ADD		s0, INC_X	; Move temp_cursor one position
		OUTPUT	s0, PA_RAM_W_ADDR
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_s3_done	; if temp_ship_length is zero, we are done
		ADD		s0, INC_X	; Move temp_cursor one position
		OUTPUT	s0, PA_RAM_W_ADDR
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_s3_done	; if temp_ship_length is zero, we are done
		ADD		s0, INC_X	; Move temp_cursor one position
		OUTPUT	s0, PA_RAM_W_ADDR
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_s3_done	; if temp_ship_length is zero, we are done
		ADD		s0, INC_X	; Move temp_cursor one position
		OUTPUT	s0, PA_RAM_W_ADDR
		JUMP	next_mvmt_s3_done	; max length is 5, so don't need to check anymore

next_mvmt_s3_s:
		; Write values to RAM starting at anchor (Cursor) and adding Y value, ship_length times (s1)
		LOAD	s0, RAM_SHIP_H	; Load place ship value into what value we are writing to ram
		OUTPUT	s0, PA_RAM_W_VAL	; Tell the interface to write SHIP to RAM address
		LOAD	s0,	Cursor	; s0 becomes temp_cursor
		OUTPUT	s0, PA_RAM_W_ADDR
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_s3_done	; if temp_ship_length is zero, we are done
		ADD		s0, INC_Y	; Move temp_cursor one position
		OUTPUT	s0, PA_RAM_W_ADDR
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_s3_done	; if temp_ship_length is zero, we are done
		ADD		s0, INC_Y	; Move temp_cursor one position
		OUTPUT	s0, PA_RAM_W_ADDR
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_s3_done	; if temp_ship_length is zero, we are done
		ADD		s0, INC_Y	; Move temp_cursor one position
		OUTPUT	s0, PA_RAM_W_ADDR
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_s3_done	; if temp_ship_length is zero, we are done
		ADD		s0, INC_Y	; Move temp_cursor one position
		OUTPUT	s0, PA_RAM_W_ADDR
		JUMP	next_mvmt_s3_done	; max length is 5, so don't need to check anymore

next_mvmt_s3_w:
		; Write values to RAM starting at anchor (Cursor) and subtracting X value, ship_length times (s1)
		LOAD	s0, RAM_SHIP_H	; Load place ship value into what value we are writing to ram
		OUTPUT	s0, PA_RAM_W_VAL	; Tell the interface to write SHIP to RAM address
		LOAD	s0,	Cursor	; s0 becomes temp_cursor
		OUTPUT	s0, PA_RAM_W_ADDR
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_s3_done	; if temp_ship_length is zero, we are done
		SUB		s0, INC_X	; Move temp_cursor one position
		OUTPUT	s0, PA_RAM_W_ADDR
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_s3_done	; if temp_ship_length is zero, we are done
		SUB		s0, INC_X	; Move temp_cursor one position
		OUTPUT	s0, PA_RAM_W_ADDR
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_s3_done	; if temp_ship_length is zero, we are done
		SUB		s0, INC_X	; Move temp_cursor one position
		OUTPUT	s0, PA_RAM_W_ADDR
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_s3_done	; if temp_ship_length is zero, we are done
		SUB		s0, INC_X	; Move temp_cursor one position
		OUTPUT	s0, PA_RAM_W_ADDR
		JUMP	next_mvmt_s3_done	; max length is 5, so don't need to check anymore

        
next_mvmt_s3_done:
		; decrement ship count and ship length (if appropriate)
		SUB		Ship_info, INC_SHIPCNT	; decrement ship_count
		LOAD	s0, Ship_info	; see what count we are at if we need to decrement ship_length
		AND		s0, MSK_SHIPCNT	; Mask just to look at the ship count
		COMPARE	s0, 20			; if we are at ship_count = 2 now, do not decrement ship_length (next ship is still length 3)
		JUMP	Z, next_mvmt_s3_skip_dec
		SUB		Ship_info, INC_SHIPLNG	; else, decrement ship_length
next_mvmt_s3_skip_dec:
        LOAD    s0, STATE1		; We are only in state 3 for one round, go back to state 1
        STORE   s0, SP_STATE
		LOAD	Cursor, CURSOR_INIT	; Reset cursor and orientation to intial values
		LOAD	Orien, EAST
        RETURN
        
; Send out finished placing ships signal		
next_mvmt_s4:
        ;JUMP    the_end             ; We have completed the track, shut off processing.
		
		FETCH	s0, SP_PLAYER_NUMBER
		COMPARE	s0, SP_PLAYER_ONE
		JUMP	Z, next_mvmt_s4_go_first
		LOAD	s0, HIS_TURN		; player 2 goes second
		JUMP	next_mvmt_s4_send
		
next_mvmt_s4_go_first:	
		LOAD	s0, MY_TURN			; player 1 goes first
		
next_mvmt_s4_send:
		OUTPUT	s0, PA_PLACE_DONE
		
		LOAD	s0, TRUE
		STORE	s0, SP_PLACE_DONE
		
		;Testing purposes, set LED outputs to 1 for LED... upper I guess
		LOAD	s1, FF
		CALL LED_wrleds_hi
        RETURN

; --------------------------
; State transition actions
; --------------------------
next_mvmt_go_s1:
		; Check and see if current location within RAM is valid or not
		LOAD	s1,	Cursor
		OUTPUT	s1, PA_CURSOR_CHECK

        LOAD    s0, STATE1
        STORE   s0, SP_STATE
        RETURN

           
next_mvmt_go_s2:
; We are transitioning into state 2, so we need to check the ship length values
		LOAD    s0, STATE2
        STORE   s0, SP_STATE    ; State is now state 2
		
collision_detection:
; COLLISION DETECTION FOR WHOLE LENGTH OF THE SHIP
		; Get ship orientation and perform appropriate actions
		LOAD	s1,	Ship_info	; get ship info reg to use later
		AND		s1,	MSK_SHIPLNG	; Mask to get just ship length
		
		LOAD	s0, Orien	; get ship orientation
		COMPARE	s0, NORTH	; See if we are pointing North
		JUMP	Z,	next_mvmt_go_s2_n
		COMPARE	s0,	EAST	; See if we are pointing East
		JUMP	Z,	next_mvmt_go_s2_e
		COMPARE	s0, SOUTH	; See if we are pointing South
		JUMP	Z,	next_mvmt_go_s2_s
		JUMP	next_mvmt_go_s2_w	; We must be pointing West
		
next_mvmt_go_s2_n:
		; First check and make sure ship will be within the bounds of the game
		; receive length in LSB..... must compare by subtracting with Y's value to ensure it fits in game board bounds
		LOAD	s0,	Cursor		; Get Y value into s0, going to subtract length (s1) from it (go north)
		AND		s0,	Y_COOR
		ADD		s0, 01			; Adding 1 to the value, to allow for minimum to work
		SUB		s0, s1			; y_coor = y_coor - length
		JUMP	C,	out_of_bounds; Carry flag, when set, indicates an underflow (borrow) occurred
		;s1 still contains Ship_Length
		
		LOAD	s0,	Cursor	; s0 becomes temp_cursor
		OUTPUT	s0, PA_SHIP_CHECK_0
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_go_s2_done	; if temp_ship_length is zero, we are done
		SUB		s0, INC_Y	; Move temp_cursor one position
		OUTPUT	s0, PA_SHIP_CHECK_1
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_go_s2_done	; if temp_ship_length is zero, we are done
		SUB		s0, INC_Y	; Move temp_cursor one position
		OUTPUT	s0, PA_SHIP_CHECK_2
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_go_s2_done	; if temp_ship_length is zero, we are done
		SUB		s0, INC_Y	; Move temp_cursor one position
		OUTPUT	s0, PA_SHIP_CHECK_3
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_go_s2_done	; if temp_ship_length is zero, we are done
		SUB		s0, INC_Y	; Move temp_cursor one position
		OUTPUT	s0, PA_SHIP_CHECK_4
		JUMP	next_mvmt_go_s2_done	; max length is 5, so don't need to check anymore
		

next_mvmt_go_s2_e:
		; First check and make sure ship will be within the bounds of the game
		LOAD	s0,	Cursor		; Get X value into s0, going to add length (s1) to it (go east)
		AND		s0,	X_COOR
		SR0		s0				; Shift right four times to get out of upper nibble	
		SR0		s0
		SR0		s0
		SR0		s0
		ADD		s0, s1			; x_coor = x_coor + length
		LOAD	s1,	MAX_PLACE	;
		COMPARE	s1,	s0			; check if MAX_X < (X_coor + length)
		JUMP	C,	out_of_bounds; CARRY is set If sX < sY
		;s1 no longer contains Ship_Length, reload it
		LOAD	s1,	Ship_info	; get ship info reg to use later
		AND		s1,	MSK_SHIPLNG	; Mask to get just ship length
		
		LOAD	s0,	Cursor	; s0 becomes temp_cursor
		OUTPUT	s0, PA_SHIP_CHECK_0
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_go_s2_done	; if temp_ship_length is zero, we are done
		ADD		s0, INC_X	; Move temp_cursor one position
		OUTPUT	s0, PA_SHIP_CHECK_1
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_go_s2_done	; if temp_ship_length is zero, we are done
		ADD		s0, INC_X	; Move temp_cursor one position
		OUTPUT	s0, PA_SHIP_CHECK_2
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_go_s2_done	; if temp_ship_length is zero, we are done
		ADD		s0, INC_X	; Move temp_cursor one position
		OUTPUT	s0, PA_SHIP_CHECK_3
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_go_s2_done	; if temp_ship_length is zero, we are done
		ADD		s0, INC_X	; Move temp_cursor one position
		OUTPUT	s0, PA_SHIP_CHECK_4
		JUMP	next_mvmt_go_s2_done	; max length is 5, so don't need to check anymore		
		
		

next_mvmt_go_s2_s:
		; First check and make sure ship will be within the bounds of the game
		LOAD	s0,	Cursor		; Get Y value into s0, going to add length (s1) to it (go south)
		AND		s0,	Y_COOR
		ADD		s0, s1			; y_coor = y_coor + length
		LOAD	s1,	MAX_PLACE
		COMPARE	s1,	s0			; check if MAX_Y < (Y_coor + length)
		JUMP	C,	out_of_bounds; CARRY is set If sX < sY
		;s1 no longer contains Ship_Length, reload it
		LOAD	s1,	Ship_info	; get ship info reg to use later
		AND		s1,	MSK_SHIPLNG	; Mask to get just ship length
		
		LOAD	s0,	Cursor	; s0 becomes temp_cursor
		OUTPUT	s0, PA_SHIP_CHECK_0
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_go_s2_done	; if temp_ship_length is zero, we are done
		ADD		s0, INC_Y	; Move temp_cursor one position
		OUTPUT	s0, PA_SHIP_CHECK_1
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_go_s2_done	; if temp_ship_length is zero, we are done
		ADD		s0, INC_Y	; Move temp_cursor one position
		OUTPUT	s0, PA_SHIP_CHECK_2
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_go_s2_done	; if temp_ship_length is zero, we are done
		ADD		s0, INC_Y	; Move temp_cursor one position
		OUTPUT	s0, PA_SHIP_CHECK_3
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_go_s2_done	; if temp_ship_length is zero, we are done
		ADD		s0, INC_Y	; Move temp_cursor one position
		OUTPUT	s0, PA_SHIP_CHECK_4
		JUMP	next_mvmt_go_s2_done	; max length is 5, so don't need to check anymore
		

next_mvmt_go_s2_w:	
		; First check and make sure ship will be within the bounds of the game
		LOAD	s0,	Cursor		; Get X value into s0, going to subtract length (s1) from it (go west)
		AND		s0,	X_COOR
		SR0		s0				; Shift right four times to get out of upper nibble	
		SR0		s0
		SR0		s0
		SR0		s0
		ADD		s0, 01			; Adding 1 to the value, to allow for minimum to work
		SUB		s0, s1			; x_coor = x_coor - length
		JUMP	C,	out_of_bounds; Carry flag, when set, indicates an underflow (borrow) occurred
		;s1 still contains Ship_Length
		
		LOAD	s0,	Cursor	; s0 becomes temp_cursor
		OUTPUT	s0, PA_SHIP_CHECK_0
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_go_s2_done	; if temp_ship_length is zero, we are done
		SUB		s0, INC_X	; Move temp_cursor one position
		OUTPUT	s0, PA_SHIP_CHECK_1
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_go_s2_done	; if temp_ship_length is zero, we are done
		SUB		s0, INC_X	; Move temp_cursor one position
		OUTPUT	s0, PA_SHIP_CHECK_2
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_go_s2_done	; if temp_ship_length is zero, we are done
		SUB		s0, INC_X	; Move temp_cursor one position
		OUTPUT	s0, PA_SHIP_CHECK_3
		SUB		s1, 01		; decrement temp_ship_length
		JUMP	Z,	next_mvmt_go_s2_done	; if temp_ship_length is zero, we are done
		SUB		s0, INC_X	; Move temp_cursor one position
		OUTPUT	s0, PA_SHIP_CHECK_4
		JUMP	next_mvmt_go_s2_done	; max length is 5, so don't need to check anymore
		
out_of_bounds:
		; We get here if the current location, orientation, and ship length invalidate this as a possible ship placement location
		; However, the validate flag is set through the ISR reading in register values. We need to force this to set it to invalid
		; Going to cheat and use a defined invalid location the hardware will pick up on and set the output as invalid
		LOAD	s0, OUT_OF_BOUNDS
		STORE	s0, SP_OOB
		
next_mvmt_go_s2_done:
		RETURN	

next_mvmt_go_s3:
		LOAD    s0, STATE3
        STORE   s0, SP_STATE
        RETURN		

next_mvmt_go_s4:
        LOAD    s0, STATE4
        STORE   s0, SP_STATE
        RETURN
								

; ==============================================================================
; === next_hdg() - Calculate  digits for heading (compass setting)           ===
; === Registers affected: Dig7, Dig6, Dig5, s0, s1, s2, s3,s4, s5, s6        ===
; === Uses Botinf (Bot Info register) to get orientation.  Calculates digits ===
; === with a case statement based on orientation.                            ===  
; ==============================================================================				

			

;===============================================================================
;
;=======================  BEGIN JORDAN FLUTH    ================================
;
;===============================================================================
; ==============================================================================
; === next_loc() - Calculate digits for Rojobot location                     ===
; === Registers affected: Dig3, Dig2, Dig1, Dig0, s0                         ===
; === Uses LocX and LocY to get location.                                    ===  
; ==============================================================================
DISP_X_Y:		LOAD		s0,		Cursor				; Dig[3:2] gets X-coordinate
				AND 		s0, 	X_COOR
				SL0 		s0
				SL0 		s0
				SL0 		s0
				SL0 		s0	
				LOAD		Dig1,	s0					; Digit 2 gets lower nibble
				
				LOAD		s0,		Cursor				; Dig[1:0] gets Y-coordinate
				AND 		s0, 	Y_COOR
				LOAD		Dig0,	s0					; Digit 0 gets lower nibble
	
				RETURN


;===============================================================================
;
;=======================  SET PLAYER ONE AND PLAYER TWO   ======================
;
;===============================================================================
PLAYER_ASSIGN: 	LOAD 	s0, 	PA_SLSWTCH
 				OUTPUT 	s0, 	PA_LEDS1508
 				COMPARE s0, 	MSK_SW0
 				JUMP 	Z, 		SET_PLAYER_ONE
 				JUMP 	NZ, 	SET_PLAYER_TWO
				
				
SET_PLAYER_ONE: LOAD  s0, 	SP_PLAYER_ONE
				STORE s0,	SP_PLAYER_NUMBER
				LOAD 	s0, 			SP_READ_BTNS
				STORE 	s0, 			SP_GAME_STATE
				LOAD 	s0, 			80
				OUTPUT 	s0, 			PA_LEDS1508
				RETURN

SET_PLAYER_TWO: LOAD  s0, 	SP_PLAYER_TWO
				STORE s0,	SP_PLAYER_NUMBER
				LOAD 	s0, 			SP_RECEIVING
				STORE 	s0, 			SP_GAME_STATE
				LOAD 	s0, 			E0
				OUTPUT 	s0, 			PA_LEDS1508
				RETURN

;===============================================================================
;
;=======================  TURN FUNCTIONALITY   =================================
;
;===============================================================================
TURN:			FETCH 	s0, 	SP_PLACE_DONE    	; WAIT UNTIL THE SHIPS HAVE BEEN PLACED
				COMPARE s0, 	TRUE
				JUMP 	NZ, 	ERROR
				LOAD 	s0, 	AA
				OUTPUT 	s0, 	PA_LEDS1508

				; GO TO THE RIGHT STATE
				FETCH 	s0, 	SP_GAME_STATE
				OUTPUT 	s0, 	PA_LEDS1508 		; -- DEBUG
				COMPARE s0, 	SP_READ_BTNS 
				JUMP 	Z, 		READBTN
				COMPARE s0,	 	SP_SENDING
				JUMP 	Z, 		SEND_GUESS
				COMPARE s0, 	SP_RECEIVING
				JUMP 	Z, 		RECEIVE_GUESS
				COMPARE s0, 	SP_RCVE_RESULT
				JUMP 	Z, 		RCVE_RESULT	
				COMPARE s0, 	SP_SEND_ACK
				JUMP 	Z, 		SEND_ACK
				COMPARE s0, 	SP_RCVE_ACK
				JUMP 	Z, 		RCVE_ACK
				JUMP 	ERROR


READBTN:		;CALL	DEB_rdbtns					; Read the pushbuttons. buttons returned in s0
				;CALL	btn2mot						; and calculate new MotCtl - returned in s1

				LOAD	s0, But_input				; Read button input
				AND		s0, MSK_ALLBTNS				; Mask out just the buttons
				COMPARE	s0, MSK_BTN_UP				; See if only the up button was pressed

				COMPARE s0, 	MSK_BTN_UP
				JUMP 	Z,		UP 	
				COMPARE s0, 	MSK_BTN_DOWN
				JUMP 	Z,		DOWN 
				COMPARE s0, 	MSK_BTN_LEFT
				JUMP 	Z,		LEFT 														
				COMPARE s0, 	MSK_BTN_RIGHT
				JUMP 	Z,		RIGHT 
				COMPARE s0, 	MSK_BTN_CENTER
				JUMP 	Z,		SEND_GUESS
				JUMP 	ERROR 


UP:				LOAD 	s0, 	Cursor
				AND		s0,		Y_COOR	
				COMPARE s0, 	MIN_Y
				JUMP 	Z, 		ERROR
				SUB 	Cursor, INC_Y
				LOAD 	s0, 	SP_READ_BTNS
				OUTPUT 	s0, 	PA_LEDS1508 		; -- DEBUG
				STORE 	s0, 	SP_GAME_STATE
				RETURN

DOWN:			LOAD 	s0, 	Cursor
				AND 	s0, 	Y_COOR
				COMPARE s0, 	MAX_Y
				JUMP 	Z, 		ERROR
				ADD 	Cursor, INC_Y
				LOAD 	s0, 	SP_READ_BTNS
				OUTPUT 	s0, 	PA_LEDS1508 		; -- DEBUG
				STORE 	s0, 	SP_GAME_STATE
				RETURN

LEFT:			LOAD 	s0, 	Cursor
				AND		s0,		X_COOR	
				COMPARE s0, 	MIN_X
				JUMP 	Z, 		ERROR
				SUB 	Cursor, INC_X
				LOAD 	s0, 	SP_READ_BTNS
				OUTPUT 	s0, 	PA_LEDS1508 		; -- DEBUG
				STORE 	s0, 	SP_GAME_STATE
				RETURN

RIGHT:			LOAD 	s0, 	Cursor
				AND 	s0, 	X_COOR
				COMPARE s0, 	MAX_X
				JUMP 	Z, 		ERROR
				ADD 	Cursor, INC_X
				LOAD 	s0, 	SP_READ_BTNS
				OUTPUT 	s0, 	PA_LEDS1508 		; -- DEBUG
				STORE 	s0, 	SP_GAME_STATE
				RETURN

SEND_GUESS:		LOAD 	s0, 	Cursor
				OUTPUT 	s0, 	PA_RAM_W_ADDR 		; GET THE CURRENT CURSOR POSITION
				INPUT 	s1, 	PA_DATA_RAM	 		; GET THE DATA IN THAT RAM LOCATION
				COMPARE s1, 	RAM_MISS 			 	; CHECK TO SEE IF ITS ALREADY BEEN GUESSED
				JUMP 	Z, 		ERROR 				; LOCATION ALREADY GUESSED
				STORE  	s0,	 	SP_GUESS 			
				OUTPUT 	s0, 	PA_DATA_TX 			; SEND THE GUESS
				LOAD	s0,		HIS_TURN
				OUTPUT	s0,		PA_PLACE_DONE

				LOAD 	s0, 	SP_RCVE_RESULT
				OUTPUT 	s0, 	PA_LEDS1508 		; -- DEBUG
				STORE 	s0, 	SP_GAME_STATE 		; UPDATE THE GAME STATE
				RETURN

RECEIVE_GUESS:	INPUT 	s0, 	PA_CONN_EST
				AND 	s0, 	DATA_READY_MASK
				COMPARE s0, 	DATA_READY_MASK
				JUMP 	NZ, 	RECEIVE_GUESS
				
				LOAD	s0,		MY_TURN
				OUTPUT	s0,		PA_PLACE_DONE

				INPUT 	s0, 	PA_DATA_RX 	 		; GET THE GUESS FROM THE OTHER PLAYER
				LOAD 	s1, 	s0
				OUTPUT 	s1, 	PA_RAM_W_ADDR 	 	; SEND THE XY TO THE RAM
				INPUT 	s0, 	PA_DATA_RAM	 		; READ DATA AT THAT LOCATION

				COMPARE s0, 	RAM_SHIP
				JUMP 	Z, 		MARK_HIT
				COMPARE s0, 	RAM_EMPTY
				JUMP 	Z, 		MARK_MISS
				JUMP ERROR 

MARK_HIT:		FETCH 	s0, 	SP_HIT_COUNT
				ADD 	s0, 	01
				STORE 	s0, 	SP_HIT_COUNT
				COMPARE s0, 	MAX_HITS
				JUMP 	Z, 		MARK_LOSE
				LOAD 	s0, 	RAM_HIT 
				JUMP 	SEND_MARK

MARK_MISS:		LOAD 	s0, 	RAM_MISS 
				JUMP 	SEND_MARK

MARK_LOSE: 		LOAD 	s0, 	LOSE_CODE
				OUTPUT 	s0, 	PA_DATA_TX
				JUMP 	GAME_OVER

SEND_MARK: 		OUTPUT 	s0, 	PA_DATA_TX
				LOAD 	s0, 	SP_RCVE_ACK		; UPDATE THE GAME STATE
				OUTPUT 	s0, 	PA_LEDS1508 		; -- DEBUG
				STORE 	s0, 	SP_GAME_STATE
				RETURN


RCVE_RESULT: 	INPUT 	s0, 	PA_CONN_EST
				AND 	s0, 	DATA_READY_MASK
				COMPARE s0, 	DATA_READY_MASK
				JUMP 	NZ, 	RCVE_RESULT

				INPUT 	s0, 	PA_DATA_RX 			; READ THE RESPONSE
				COMPARE s0, 	LOSE_CODE 			; CHECK IF END OF GAME
				JUMP 	Z, 		GAME_OVER 			; INFINITE LOOP IF FINISHED

				FETCH 	s1, 	SP_GUESS 			; GET THE RAM ADDRESS
				OUTPUT 	s0, 	PA_RAM_W_VAL 		; VALUE OUT TO RAM
				OUTPUT 	s1, 	PA_RAM_W_ADDR 		; RAM ADDRESS
				LOAD 	s0, 	SP_SEND_ACK			; UPDATE THE GAME STATE
				STORE 	s0, 	SP_GAME_STATE
				RETURN  

SEND_ACK: 		LOAD 	s0, 	ACK 				; LOAD THE ACK CODE
				OUTPUT 	s0, 	PA_DATA_TX			; SEND THE ACK
				LOAD 	s0, 	SP_RECEIVING		; UPDATE THE GAME STATE
				OUTPUT 	s0, 	PA_LEDS1508 		; -- DEBUG
				STORE 	s0, 	SP_GAME_STATE
				RETURN 

RCVE_ACK: 		INPUT 	s0, 	PA_CONN_EST
				AND 	s0, 	DATA_READY_MASK
				COMPARE s0, 	DATA_READY_MASK
				JUMP 	NZ, 	RCVE_ACK

				INPUT 	s0, 	PA_DATA_RX 			
				COMPARE s0, 	ACK
				JUMP 	NZ, 	NOT_ACKED
				JUMP 	Z, 		ACKED
				JUMP 	ERROR

NOT_ACKED: 		LOAD 	s0, 	SP_RCVE_ACK 		; UPDATE THE GAME STATE
				OUTPUT 	s0, 	PA_LEDS1508 		; -- DEBUG
				STORE 	s0, 	SP_GAME_STATE
				RETURN

ACKED: 			LOAD 	s0, 	SP_READ_BTNS 		; UPDATE THE GAME STATE
				OUTPUT 	s0, 	PA_LEDS1508 		; -- DEBUG
				STORE 	s0, 	SP_GAME_STATE
				RETURN

ERROR:			RETURN

GAME_OVER: 		JUMP GAME_OVER 						; INFINITE LOOP


;===============================================================================
;
;=======================  END JORDAN FLUTH    ==================================
;
;===============================================================================			

;##############################################
; This function was changed for Project 2 #####	
;##############################################				

; ==============================================================================
; === next_step() - Tells rojobot what to do next                            ===    
; === Registers affected: s0, s1                                             ===
; === This version sends the new Motor Control command based on the current  ===
; === state.                                                                 ===
; ==============================================================================
next_step:		
        FETCH   s0, SP_STATE        ; get current state
        COMPARE s0, STATE0
        JUMP    Z,  next_step_idle   ; if SP_STATE is 1, go reverse
        JUMP    next_step_active   ; if SP_STATE is 1, go reverse
		
next_step_idle:
		; Do nothing, this is an idle state
		RETURN
		
next_step_active:
		FETCH	s0, SP_OOB		; out of bounds signal
		OUTPUT	s0, PA_OOB
		LOAD	s0, Cursor
		OUTPUT	s0,	PA_CURSOR_CHECK
		LOAD	s0, Orien
		OUTPUT	s0, PA_ORIEN
		LOAD	s0, Ship_info
		OUTPUT	s0, PA_SHIP_INFO

		
		RETURN
    
				
;*************************
; Nexys4 I/O Functions
;*************************

;---------------------
; DEB_rdbtns() - Reads the debounced pushbuttons
;
; Returns the 5 pushbuttons. The buttons are returned as follows
; (assuming the inputs to the I/O interface matches this order)
; example:
;    bit  7    6      5        4        3        2        1         0
;         r    r   	  r    btn_cntr  btn_left  btn_up  btn_right  btn_down
;
; where r = reserved. A value of 1 indicates that the button is pressed.  
; A 0 indicates that the button is not pressed.
;
; Registers used s0
;---------------------
DEB_rdbtns:		INPUT		s0,		PA_PBTNS			; read the buttons
				AND		s0,		MSK_ALLBTNS			; mask out unused bits
				RETURN								; and return
				
				
;---------------------
; DEB_rdsw() - Reads the low order debounced switches
;
; Returns the  low order switches  [7:0]. The switches are returned as follows
; example:
;    bit  7    6    5   4    3    2    1    0
;        sw7  sw6  sw5 sw4  sw3  sw2  sw1  sw0
;
; where r = reserved, sw7 is the leftmost switch and sw0 is the rightmost
; switch. A value of 1 indicates that the switch is on (up).  A 0 indicates that
; the switch is off (down).
;
; Registers used s0
;---------------------
DEB_rdsw:		INPUT		s0,		PA_SLSWTCH			; read the slide switches
				AND		s0,		MSK_ALLSW_LO	 	; mask out unused bits
				RETURN								; and return				

				
;---------------------
; DEB_rdsw_hi() - Reads the high order debounced switches
;
; Returns the  high order switches  [155432:0]. The switches are returned as follows
; example:
;    bit   7     6     5    4     3     2     1    0
;        sw15  sw14  sw13 sw12  sw11  sw10  sw9  sw8
;
; where r = reserved, sw15 is the leftmost switch and sw7 is the rightmost
; switch. A value of 1 indicates that the switch is on (up).  A 0 indicates that
; the switch is off (down).
;
; Registers used s0
;---------------------
DEB_rdsw_hi:	INPUT		s0,		PA_SLSWTCH1508		; read the slide switches
				AND		s0,		MSK_ALLSW_HI	 	; mask out unused bits
				RETURN								; and return	
								
;---------------------
; LED_wrleds() - Write the low order 8 LEDs
;
; Writes the pattern in s1 to the rightmost 8 LEDs on the Nexys4
;
; Registers used s0, s1
;---------------------
LED_wrleds:		LOAD		s0,		s1					; Copy LEDs to s0 to preserve them
				AND		s0,		MSK_LEDS_LO			; mask out unused bits
				OUTPUT	s0,		PA_LEDS				; and write pattern to the LEDs	
				RETURN								; and return	

;---------------------
; LED_wrleds_hi() - Write the high order 8 LEDs
;
; Writes the pattern in s1 to the lefmost 8 LEDs on the Nexys4
;
; Registers used s0, s1
;---------------------
LED_wrleds_hi:	LOAD		s0,		s1					; Copy LEDs to s0 to preserve them
				AND		s0,		MSK_LEDS_HI			; mask out unused bits
				OUTPUT	s0,		PA_LEDS1508		; and write pattern to the LEDs	
				RETURN								; and return								
				
				
;---------------------
; SS_wrdigx() - Write a digit to the righmost 4 display digits
;
; Writes the value specified in s1 to the digit number
; in s2.  The digit number must be 0, 1, 2, or 3
; All others numbers will be rejected.  
;
; Registers used s0, s1, s2, s3
;---------------------
SS_wrdigx:		LOAD		s0, 	03					; check to see if the number is <= 3
				COMPARE	s0,		s2					; 
				RETURN	C							; C=1 says s2 > 3 - out of range so return
SS_wrdigx_L1:	LOAD		s0,		PA_DIG0				; set base port address to PA_DIG0
				SUB		s0,		s2					; next subtract out the digit number.  This will give the port address
														; for the selected digit.  Cool - it works because the port
														; addresses for the digits are consecutive starting with digit 3 or 7
				LOAD		s3,		s1					; Copy the value to s3 so we can leave it unchanged
				AND		s3,		MSK_CCODE			; mask out unused character code bits		
				OUTPUT	s3,		(s0)				; abd write the digit to the display at the port pointed to by s0
				RETURN

;---------------------
; SS_wrdigx_hi() - Write a digit to the leftmost 4 display digits
;
; Writes the value specified in s1 to the digit number
; in s2.  The digit number must be 4, 5, 6, 7
; All others numbers will be rejected.  
;
; Registers used s0, s1, s2, s3
;---------------------
SS_wrdigx_hi:	LOAD		s0,		07					; check if the number is <= 7
				COMPARE	s0,		s2					; 
				RETURN	C							; C=10 says s2 <= 07 - out of range so return
				LOAD		s0,		03					; next check if the number is >= 3
				COMPARE	s0,		s2					; next check if the number is > 3
				RETURN	NC							; C=0 says s2 < 4 - out of range so return
				LOAD		s0,		PA_DIG4				; set base port address to PA_DIG4
				ADD		s0,		04					; adjust digit number offset (ex: digit 4 should be PA_DIG4+4-4)
				SUB		s0,		s2					; next subtract out the digit number.  This will give the port address
														; for the selected digit.  Cool - it works because the port
														; addresses for the digits are consecutive starting with digit 3 or 7
				LOAD		s3,		s1					; Copy the value to s3 so we can leave it unchanged
				AND		s3,		MSK_CCODE			; mask out unused character code bits		
				OUTPUT	s3,		(s0)				; and write the digit to the display at the port pointed to by s0
				RETURN				
				
;---------------------
; SS_wrdpts() - Write the decimal points for digit 3 to 0 to the display
;
; Writes the decimal points specified in s1 to the display.
; The decimal point register is formatted as follows:
;    bit   7  6  5  4   3    2     1     0
;          r  r  r  r  dp3  dp2   dp1   dp0
;
; where r = reserved, dp7 (leftmost), dp3, dp2, dp1 dp0 (rightmost) = 1
; lights the decimal point. A 0 in the position turns off the decimal point
;
; Registers used s0,s1
;---------------------
SS_wrdpts:		LOAD		s0,		s1					; Copy the decimal points to s0 to leave s1 unchanged
				AND		s0,		MSK_DECPTS			; and mask out the unused bits
				OUTPUT	s0,		PA_DP				; write the decimal points to the display
				RETURN
				
;---------------------
; SS_wrdpts_hi() - Write the decimal points for digit 7 to 4 to the display
;
; Writes the decimal points specified in s1 to the display.
; The decimal point register is formatted as follows:
;    bit   7  6  5  4   3    2     1     0
;          r  r  r  r  dp7  dp6   dp5   dp4
;
; where r = reserved, dp7 (leftmost), dp7, dp6, dp5 dp4 (rightmost) = 1
; lights the decimal point. A 0 in the position turns off the decimal point
;
; Registers used s0,s1
;---------------------
SS_wrdpts_hi:	LOAD		s0,		s1					; Copy the decimal points to s0 to leave s1 unchanged
				AND		s0,		MSK_DECPTS_HI		; and mask out the unused bits
				OUTPUT	s0,		PA_DP0704			; write the decimal points to the display
				RETURN				
	

; =========================
; === Interrupt Handler ===
; =========================
ADDRESS 300
isr:			STORE		s6,		SP_TEMP1			; 	save s6, s5
				STORE		s5,		SP_TEMP2			;
				FETCH		s6,		SP_SEM				; 	fetch the semaphore
				TEST		s6,		FF					;	if (SP_SEM == 0) {  // update system register values
				JUMP		NZ,		isr_L0				; -- ZF == 0 says semaphore != 0
													;		// no - get the data from the rojobot emulator
				INPUT		valid_flag,	PA_VALID_FLAG	; space(s) are valid for ship placement
				INPUT		But_input, PA_CONN_EST
				CALL		DEB_rdbtns
				OR			But_input, s0
				;INPUT		LocX,	PA_LOCX				;		get Rojobot X-coordinate 
				;INPUT		LocY,	PA_LOCY				;		get Rojobot Y-coordinate
				;INPUT		Botinf,	PA_BOTINFO			;		get Rojobot Movement and Orientation
				;INPUT		Sensor,	PA_SENSORS			;		get Rojobot Sensors
				;INPUT		s5,		PA_LMDIST			;		get left and right motor distance counters
				;STORE		s5,		SP_LMDIST			;		not displayed in this program but let's stash them
				;INPUT		s5,		PA_RMDIST			;		in case we decide we need them 
				;STORE		s5,		SP_RMDIST			;				  
				ADD		s6,		01					;		increment semaphore
				STORE		s6,		SP_SEM				;	}  // update system register values
isr_L0:			FETCH		s6,		SP_OLDDP			;	toggle  decimal point 0 (rightmost)
				XOR		s6,		01					;
				OUTPUT	s6,		PA_DP				;	write directly to decpt port to avoid having to save s1
				STORE		s6,		SP_OLDDP			;				
				FETCH		s6,		SP_TEMP1			; 	restore s6, s5
				FETCH		s5,		SP_TEMP2			;
				RETURNI			ENABLE				;	and return from interrupt			

; ========================
; === Interrupt vector ===
; ========================
ADDRESS 3FF
intvect:		JUMP	isr							; jump to interrupt service routine
				
